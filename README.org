#+title: Writing An Interpreter In Go
* Agenda
** 1 Lexing [5/5]
- [X] 1.1 - Lexical Analysis
- [X] 1.2 - Defining Our Tokens
- [X] 1.3 - The Lexer
- [X] 1.4 - Extending our Token Set and Lexer
- [X] 1.5 - Start of a REPL
** 2 Parsing [23/23]
:LOGBOOK:
CLOCK: [2022-09-14 Wed 10:46]--[2022-09-14 Wed 11:11] =>  0:25
CLOCK: [2022-09-14 Wed 10:01]--[2022-09-14 Wed 10:26] =>  0:25
CLOCK: [2022-09-14 Wed 09:22]--[2022-09-14 Wed 09:47] =>  0:25
CLOCK: [2022-09-14 Wed 08:51]--[2022-09-14 Wed 09:16] =>  0:25
CLOCK: [2022-09-13 Tue 12:04]--[2022-09-13 Tue 12:18] =>  0:14
CLOCK: [2022-09-13 Tue 11:30]--[2022-09-13 Tue 11:55] =>  0:25
CLOCK: [2022-09-13 Tue 10:53]--[2022-09-13 Tue 11:18] =>  0:25
CLOCK: [2022-09-13 Tue 10:11]--[2022-09-13 Tue 10:36] =>  0:25
CLOCK: [2022-09-13 Tue 09:39]--[2022-09-13 Tue 10:04] =>  0:25
CLOCK: [2022-09-12 Mon 10:31]--[2022-09-12 Mon 10:56] =>  0:25
CLOCK: [2022-09-12 Mon 09:49]--[2022-09-12 Mon 10:14] =>  0:25
CLOCK: [2022-09-12 Mon 08:59]--[2022-09-12 Mon 09:24] =>  0:25
:END:
- [X] 2.1 - Parsers
- [X] 2.2 - Why not a parser generator?
- [X] 2.3 - Writing a Parser for the Monkey Programming Language
- [X] 2.4 - Parser’s first steps: parsing let statements
- [X] 2.5 - Parsing Return Statements
- [X] 2.6 - Parsing Expressions
- [X] Expressions in Monkey
- [X] Top Down Operator Precedence (or: Pratt Parsing)
- [X] Terminology
- [X] Preparing the AST
- [X] IIdentifiers
- [X] Integer Literals
- [X] Prefix Operators
- [X] Infix Operators
- [X] 2.7 - How Pratt Parsing Works
- [X] 2.8 - Extending the Parser
- [X] Boolean Literals
- [X] Grouped Expressions
- [X] If Expressions
- [X] Function Literals
- [X] Call Expressions
- [X] Removing TODOs
- [X] 2.9 - Read-Parse-Print-Loop
** 3 Evaluation [18/21]
:LOGBOOK:
CLOCK: [2022-09-16 Fri 09:18]--[2022-09-16 Fri 09:43] =>  0:25
CLOCK: [2022-09-16 Fri 08:51]--[2022-09-16 Fri 09:16] =>  0:25
CLOCK: [2022-09-16 Fri 08:16]--[2022-09-16 Fri 08:41] =>  0:25
:END:
- [X] 3.1 - Giving Meaning to Symbols
- [X] 3.2 - Strategies of Evaluation
- [X] 3.3 - A Tree-Walking Interpreter
- [X] 3.4 - Representing Objects
- [X] Foundation of our Object System
- [X] Integers
- [X] Booleans
- [X] Null
- [X] 3.5 - Evaluating Expressions
- [X] Integer Literals
- [X] Completing the REPL
- [X] Boolean Literals
- [X] Null
- [X] Prefix Expressions
- [X] Infix Expressions
- [X] 3.6 - Conditionals
- [X] 3.7 - Return Statements
- [X] 3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling
- [X] 3.9 - Bindings & The Environment
- [X] 3.10 - Functions & Function Calls
- [X] 3.11 - Who’s taking the trash out?
** 4 Extending the Interpreter [/]
- [ ] 4.1 - Data Types & Functions
- [ ] 4.2 - Strings
- [ ] Supporting Strings in our Lexer
- [ ] Parsing Strings
- [ ] Evaluating Strings
- [ ] String Concatenation
- [ ] 4.3 - Built-in Functions
- [ ] len
- [ ] 4.4 - Array
- [ ] Supporting Arrays in our Lexer
- [ ] Parsing Array Literals
- [ ] Parsing Index Operator Expressions
- [ ] Evaluating Array Literals
- [ ] Evaluating Index Operator Expressions
- [ ] Adding Built-in Functions for Arrays
- [ ] Test-Driving Arrays
- [ ] 4.5 - Hashes
- [ ] Lexing Hash Literals
- [ ] Parsing Hash Literals
- [ ] Hashing Objects
- [ ] Evaluating Hash Literals
- [ ] Evaluating Index Expressions With Hashes
- [ ] 4.6 - The Grand Finale
