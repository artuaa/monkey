#+title: Writing An X In Go
* Writing An Interpreter In Go
** 1 Lexing [5/5]
- [X] 1.1 - Lexical Analysis
- [X] 1.2 - Defining Our Tokens
- [X] 1.3 - The Lexer
- [X] 1.4 - Extending our Token Set and Lexer
- [X] 1.5 - Start of a REPL
** 2 Parsing [23/23]
- [X] 2.1 - Parsers
- [X] 2.2 - Why not a parser generator?
- [X] 2.3 - Writing a Parser for the Monkey Programming Language
- [X] 2.4 - Parser’s first steps: parsing let statements
- [X] 2.5 - Parsing Return Statements
- [X] 2.6 - Parsing Expressions
- [X] Expressions in Monkey
- [X] Top Down Operator Precedence (or: Pratt Parsing)
- [X] Terminology
- [X] Preparing the AST
- [X] IIdentifiers
- [X] Integer Literals
- [X] Prefix Operators
- [X] Infix Operators
- [X] 2.7 - How Pratt Parsing Works
- [X] 2.8 - Extending the Parser
- [X] Boolean Literals
- [X] Grouped Expressions
- [X] If Expressions
- [X] Function Literals
- [X] Call Expressions
- [X] Removing TODOs
- [X] 2.9 - Read-Parse-Print-Loop
** 3 Evaluation [21/21]
- [X] 3.1 - Giving Meaning to Symbols
- [X] 3.2 - Strategies of Evaluation
- [X] 3.3 - A Tree-Walking Interpreter
- [X] 3.4 - Representing Objects
- [X] Foundation of our Object System
- [X] Integers
- [X] Booleans
- [X] Null
- [X] 3.5 - Evaluating Expressions
- [X] Integer Literals
- [X] Completing the REPL
- [X] Boolean Literals
- [X] Null
- [X] Prefix Expressions
- [X] Infix Expressions
- [X] 3.6 - Conditionals
- [X] 3.7 - Return Statements
- [X] 3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling
- [X] 3.9 - Bindings & The Environment
- [X] 3.10 - Functions & Function Calls
- [X] 3.11 - Who’s taking the trash out?
** 4 Extending the Interpreter [23/23]
- [X] 4.1 - Data Types & Functions
- [X] 4.2 - Strings
- [X] Supporting Strings in our Lexer
- [X] Parsing Strings
- [X] Evaluating Strings
- [X] String Concatenation
- [X] 4.3 - Built-in Functions
- [X] len
- [X] 4.4 - Array
- [X] Supporting Arrays in our Lexer
- [X] Parsing Array Literals
- [X] Parsing Index Operator Expressions
- [X] Evaluating Array Literals
- [X] Evaluating Index Operator Expressions
- [X] Adding Built-in Functions for Arrays
- [X] Test-Driving Arrays
- [X] 4.5 - Hashes
- [X] Lexing Hash Literals
- [X] Parsing Hash Literals
- [X] Hashing Objects
- [X] Evaluating Hash Literals
- [X] Evaluating Index Expressions With Hashes
- [X] 4.6 - The Grand Final
* Writing An Compiler In Go
** Introduction [4/4]
 - [X] Evolving Monkey
 - [X] The Past and Present
 - [X] The Future
 - [X] Use This Book
** 1 Compilers & Virtual Machines [7/7]
 - [X] Compiles
 - [X] Virtual and Real Machines
 - [X] Real Machines
 - [X] What Is a Virtual Machine?
 - [X] Why Build One?
 - [X] Bytecode
 - [X] What We’re Going to Do, or: the Duality of VM and Compiler
** 2 Hello Bytecode! [8/8]
 - [X] First Instructions
 - [X] Starting With Bytes
 - [X] The Smallest Compiler
 - [X] Bytecode, Disassemble!
 - [X] Back to the Task at Hand
 - [X] Powering On the Machine
 - [X] Adding on the Stack
 - [X] Hooking up the REPL
** 3 Compiling Expressions [5/5]
 - [X] Cleaning Up the Stack
 - [X] Infix Expressions
 - [X] Booleans
 - [X] Comparison Operators
 - [X] Prefix Expressions
** 4 Conditionals [2/4]
 - [X] Jumps
 - [X] Compiling Conditionals
 - [ ] Executing Jumps
 - [ ] Welcome Back, Null!
** 5 Keeping Track of Names [/]
 - [ ] The Plan
 - [ ] Compiling Bindings
 - [ ] Introducing: the Symbol Table
 - [ ] Using Symbols in the Compiler
 - [ ] Adding Globals to the VM
** 6 String, Array and Hash [/]
 - [ ] String
 - [ ] Array
 - [ ] Hash
 - [ ] Adding the index operator
** 7 Functions [/]
 - [ ] Dipping Our Toes: a Simple Function
 - [ ] Representing Functions
 - [ ] Opcodes to Execute Functions
 - [ ] Compiling Function Literals
 - [ ] Compiling Function Calls
 - [ ] Functions in the VM
 - [ ] A Little Bonus
 - [ ] Local Bindings
 - [ ] Opcodes for Local Bindings
 - [ ] Compiling Locals
 - [ ] Implementing Local Bindings in the VM
 - [ ] Arguments
 - [ ] Compiling Calls With Arguments
 - [ ] Resolving References to Arguments
 - [ ] Arguments in the VM
** 8 Built-in Functions [/]
 - [ ] Making the Change Easy
 - [ ] Making the Change: the Plan
 - [ ] A New Scope for Built-in Functions
 - [ ] Executing built-in functions
** 9 Closures [/]
 - [ ] The Problem
 - [ ] The Plan
 - [ ] Everything’s a closure
 - [ ] Compiling and resolving free variables
 - [ ] Creating real closures at run time
 - [ ] Recursive Closures
** 10 Taking Time
